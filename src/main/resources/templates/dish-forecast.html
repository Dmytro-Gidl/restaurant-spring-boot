<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8"/>
    <title th:text="#{dishForecast.title}">Dish Forecast</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
            crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        body {
            background: linear-gradient(rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.9)),
            url('/images/saveInPhotoshop.png') no-repeat center center;
            background-size: cover;
            color: #fff;
        }
        .card {
            background-color: rgba(255, 255, 255, 0.1);
            border: none;
        }
        .search-form { max-width: 250px; }
        .chart-container { height: 250px; }
        .form-select option { background-color: #343a40; color: #fff; }
    </style>
</head>
<body>
<div th:replace="fragments/topnav :: navbar"></div>
<div class="container my-4">
    <div class="mb-3">
        <h5>Model performance (k-fold)</h5>
        <table class="table table-sm text-light">
            <thead><tr><th>Model</th><th>MAPE</th><th>RMSE</th></tr></thead>
            <tbody>
            <tr th:each="m : ${metrics.entrySet()}">
                <td th:text="${m.key}"></td>
                <td th:text="${T(java.lang.Double).isNaN(m.value.mape) ? 'n/a' : #numbers.formatDecimal(m.value.mape,1,2)}"></td>
                <td th:text="${T(java.lang.Double).isNaN(m.value.rmse) ? 'n/a' : #numbers.formatDecimal(m.value.rmse,1,2)}"></td>
            </tr>
            </tbody>
        </table>
    </div>
    <div class="d-flex justify-content-between align-items-center mb-3">
        <div class="d-flex align-items-center">
            <h2 class="mb-0" th:text="#{dishForecast.title}">Dish Forecast</h2>
        </div>
        <form class="d-flex" method="get" th:action="@{/admin/dish-forecast}">
            <select name="model" class="form-select form-select-sm me-2 bg-dark text-light border-secondary">
                <option th:each="m : ${models}" th:value="${m}" th:text="${m}" th:selected="${model == m}"></option>
            </select>
            <select name="type" class="form-select form-select-sm me-2 bg-dark text-light border-secondary">
                <option value="" th:selected="${type == null}" th:text="#{dishForecast.filter.category.all}">All</option>
                <option th:each="c : ${categories}" th:value="${c}" th:selected="${type == c}"
                        th:text="${#strings.capitalize(c.toString().toLowerCase())}">Category</option>
            </select>
            <input type="text" name="filter" th:value="${filter}"
                   th:placeholder="#{dishForecast.filter.placeholder}"
                   class="form-control form-control-sm me-2 search-form bg-transparent text-light border-secondary">
            <button class="btn btn-sm btn-outline-light" type="submit"><i class="bi bi-search"></i></button>
        </form>
    </div>
    <div class="row justify-content-center mb-4" th:if="${summary != null}">
        <div class="col-md-8">
            <div class="card h-100 shadow-sm text-center">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h5 class="mb-0" th:text="#{dishForecast.total}">Total</h5>
                        <select id="summary-scale" class="form-select form-select-sm bg-dark text-light border-secondary w-auto" th:title="#{dishForecast.scale}">
                            <option value="monthly" th:text="#{dishForecast.monthly}" selected>Monthly</option>
                            <option value="daily" th:text="#{dishForecast.daily}">Daily</option>
                            <option value="hourly" th:text="#{dishForecast.hourly}">Hourly</option>
                        </select>
                    </div>
                    <div class="chart-container" style="height:300px;">
                        <canvas id="summary-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="row row-cols-1 row-cols-md-2 g-4" th:if="${forecasts != null && !forecasts.isEmpty()}">
        <div class="col" th:each="f : ${forecasts}">
            <div class="card h-100 shadow-sm">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <div class="d-flex align-items-center">
                            <img th:if="${f.imagePath != null}" th:src="@{${f.imagePath}}" alt="dish image"
                                 style="width:40px;height:40px;object-fit:cover" class="me-2 rounded">
                            <h5 class="mb-0" th:text="${f.name}">Dish</h5>
                        </div>
                        <select class="form-select form-select-sm bg-dark text-light border-secondary w-auto"
                                th:attr="id=${'scale-' + f.id}" th:title="#{dishForecast.scale}">
                            <option value="monthly" th:text="#{dishForecast.monthly}" selected>Monthly</option>
                            <option value="daily" th:text="#{dishForecast.daily}">Daily</option>
                            <option value="hourly" th:text="#{dishForecast.hourly}">Hourly</option>
                        </select>
                    </div>
                    <div class="chart-container">
                        <canvas th:if="${!f.noData}" th:attr="id=${'chart-' + f.id}"></canvas>
                        <div th:if="${f.noData}"
                             class="d-flex justify-content-center align-items-center h-100 text-muted fs-4">
                            <span role="img" aria-label="no data" class="me-2">ðŸ“‚</span>
                            <span>No data</span>
                        </div>
                    </div>
                    <p class="text-warning small mt-2" th:if="${f.noData}">No completed orders yet; forecasts start after some history is recorded.</p>
                    <p class="text-warning small mt-2" th:if="${!f.noData && f.singlePoint}">Only one month has completed orders; all models repeat this value.</p>
                    <p class="text-warning small mt-2" th:if="${!f.noData && f.emptyForecast}">The selected model returned no predictions for this dish; chart is left empty.</p>
                    <details class="text-light mt-2">
                        <summary>Details</summary>
                        <div class="small" th:attr="id=${'details-' + f.id}"></div>
                    </details>
                </div>
            </div>
        </div>
    </div>

    <div class="text-center text-light" th:if="${forecasts == null || forecasts.isEmpty()}">
        <span th:text="#{dishForecast.no.results}">No forecasts found</span>
    </div>

    <nav th:if="${page != null && page.totalPages > 1}" class="mt-3">
        <ul class="pagination justify-content-center">
            <li class="page-item" th:classappend="${page.first}? 'disabled'">
                <a class="page-link bg-dark text-light border-secondary"
                   th:href="@{/admin/dish-forecast(page=${page.number-1}, filter=${filter}, type=${type}, model=${model})}" aria-label="Previous">&laquo;</a>
            </li>
            <li class="page-item" th:each="i : ${#numbers.sequence(0, page.totalPages-1)}" th:classappend="${i==page.number}? 'active'">
                <a class="page-link bg-dark text-light border-secondary"
                   th:href="@{/admin/dish-forecast(page=${i}, filter=${filter}, type=${type}, model=${model})}"
                   th:text="${i+1}">1</a>
            </li>
            <li class="page-item" th:classappend="${page.last}? 'disabled'">
                <a class="page-link bg-dark text-light border-secondary"
                   th:href="@{/admin/dish-forecast(page=${page.number+1}, filter=${filter}, type=${type}, model=${model})}" aria-label="Next">&raquo;</a>
            </li>
        </ul>
    </nav>
</div>

<script th:inline="javascript">
/*<![CDATA[*/
const forecasts = /*[[${forecasts}]]*/ [];
const summary = /*[[${summary}]]*/ null;
const modelName = /*[[${model}]]*/ 'holt';
const zoomPlugin = window.ChartZoom?.default ?? window.ChartZoom;
Chart.register(zoomPlugin);
const charts = {};
function updateYScale(chart) {
    const all = chart.data.datasets.flatMap(d => d.data).filter(v => v !== null && v !== undefined);
    chart.options.scales.y.max = all.length ? Math.max(...all) : 1;
}

function loadDetails(id) {
    fetch(`/admin/dish-forecast/details?model=${modelName}&dishId=${id}`)
        .then(r => r.json())
        .then(d => {
            const el = document.getElementById('details-' + id);
            if (d && d.result) {
                const r = d.result;
                const ci = r.lower.length ? `[${r.lower[0].toFixed(2)}, ${r.upper[0].toFixed(2)}]` : 'n/a';
                let text = `Î±=${r.alpha.toFixed(2)}, Î²=${r.beta.toFixed(2)}, Î³=${r.gamma.toFixed(2)}, MAPE=${r.mape.toFixed(2)}, RMSE=${r.rmse.toFixed(2)}, CI=${ci}`;
                const nonZero = d.history ? d.history.filter(v => v > 0).length : 0;
                if (d.noData) {
                    text += ' â€” no completed orders yet';
                } else if (d.singlePoint) {
                    text += ' â€” based on a single month; add more completed orders for better forecasts';
                } else if (nonZero < 3) {
                    text += ' â€” limited history; forecasts may be flat across models';
                }
                el.innerText = text;
            } else {
                el.innerText = 'No details available';
            }
        })
        .catch(() => {
            const el = document.getElementById('details-' + id);
            if (el) el.innerText = 'Failed to load details';
        });
}
function computeRange(scale, labels, actual) {
    const now = new Date();
    let pos;
    if (scale === 'monthly') {
        const current = now.toISOString().slice(0,7);
        pos = labels.indexOf(current);
        if (pos < 0) pos = labels.length - 1;
        return { min: Math.max(0, pos - 6), max: Math.min(labels.length - 1, pos + 6) };
    }
    if (scale === 'daily') {
        const current = now.toISOString().slice(0,10);
        pos = labels.indexOf(current);
        if (pos < 0) pos = labels.length - 1;
        return { min: Math.max(0, pos - 7), max: Math.min(labels.length - 1, pos + 7) };
    }
    const current = now.toISOString().slice(0,13);
    pos = labels.findIndex(l => l.startsWith(current));
    if (pos < 0) pos = labels.length - 1;
    return { min: Math.max(0, pos - 24), max: Math.min(labels.length - 1, pos + 24) };
}

if (summary) {
    const ctx = document.getElementById('summary-chart').getContext('2d');
    const maxIndex = summary.labels.monthly.length - 1;
    const monthRange = computeRange('monthly', summary.labels.monthly, summary.actualData.monthly);
    const sChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: summary.labels.monthly,
            datasets: [
                {
                    label: /*[[#{dishForecast.actual}]]*/ 'Actual',
                    data: summary.actualData.monthly,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    spanGaps: true
                },
                {
                    label: /*[[#{dishForecast.predicted}]]*/ 'Forecast',
                    data: summary.forecastData.monthly,
                    borderColor: 'rgba(255, 159, 64, 1)',
                    backgroundColor: 'rgba(255, 159, 64, 0.2)',
                    spanGaps: true
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },
            scales: {
                x: {
                    min: monthRange.min,
                    max: monthRange.max,
                    ticks: { color: '#fff' },
                    grid: { color: 'rgba(255,255,255,0.1)' }
                },
                y: { beginAtZero: true, ticks: { color: '#fff', precision: 0 }, grid: { color: 'rgba(255,255,255,0.1)' } }
            },
            plugins: {
                tooltip: { enabled: true, mode: 'index', intersect: false },
                legend: { labels: { color: '#fff' } },
                zoom: {
                    pan: { enabled: false },
                    zoom: {
                        wheel: { enabled: true },
                        pinch: { enabled: true },
                        mode: 'x'
                    }
                }
            }
        }
    });

    charts.summary = { chart: sChart, data: summary, maxIndex: maxIndex };
    updateYScale(sChart);

    let startX = null;
    ctx.canvas.addEventListener('mousedown', e => { startX = e.offsetX; });
    ctx.canvas.addEventListener('mousemove', e => {
        if (startX === null) return;
        const info = charts.summary;
        const opts = info.chart.options.scales.x;
        const chartArea = info.chart.chartArea;
        const delta = (startX - e.offsetX) * (opts.max - opts.min) / (chartArea.right - chartArea.left);
        let newMin = opts.min + delta;
        let newMax = opts.max + delta;
        const range = opts.max - opts.min;
        if (newMin < 0) { newMin = 0; newMax = range; }
        if (newMax > info.maxIndex) { newMax = info.maxIndex; newMin = newMax - range; }
        opts.min = newMin;
        opts.max = newMax;
        startX = e.offsetX;
        info.chart.update('none');
    });
    ['mouseup','mouseleave'].forEach(evt => ctx.canvas.addEventListener(evt, () => startX = null));
    document.getElementById('summary-scale').addEventListener('change', e => {
        const scale = e.target.value;
        const info = charts.summary;
        info.chart.data.labels = info.data.labels[scale];
        info.chart.data.datasets[0].data = info.data.actualData[scale];
        info.chart.data.datasets[1].data = info.data.forecastData[scale];
        const range = computeRange(scale, info.data.labels[scale], info.data.actualData[scale]);
        info.maxIndex = info.data.labels[scale].length - 1;
        info.chart.options.scales.x.min = range.min;
        info.chart.options.scales.x.max = Math.min(range.max, info.maxIndex);
        updateYScale(info.chart);
        info.chart.update();
    });
}
forecasts.forEach(f => {
    if (f.noData) return;
    const ctx = document.getElementById('chart-' + f.id).getContext('2d');
    const maxIndex = f.labels.monthly.length - 1;
    const monthRange = computeRange('monthly', f.labels.monthly, f.actualData.monthly);
    const chart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: f.labels.monthly,
            datasets: [
                {
                    label: /*[[#{dishForecast.actual}]]*/ 'Actual',
                    data: f.actualData.monthly,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    spanGaps: true
                },
                {
                    label: /*[[#{dishForecast.predicted}]]*/ 'Forecast',
                    data: f.forecastData.monthly,
                    borderColor: 'rgba(255, 159, 64, 1)',
                    backgroundColor: 'rgba(255, 159, 64, 0.2)',
                    spanGaps: true
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },
            scales: {
                x: {
                    min: monthRange.min,
                    max: monthRange.max,
                    ticks: { color: '#fff' },
                    grid: { color: 'rgba(255,255,255,0.1)' }
                },
                y: { beginAtZero: true, ticks: { color: '#fff', precision: 0 }, grid: { color: 'rgba(255,255,255,0.1)' } }
            },
            plugins: {
                tooltip: { enabled: true, mode: 'index', intersect: false },
                legend: { labels: { color: '#fff' } },
                zoom: {
                    // wheel and pinch zoom remain available but panning is handled manually below
                    pan: { enabled: false },
                    zoom: {
                        wheel: { enabled: true },
                        pinch: { enabled: true },
                        mode: 'x'
                    }
                }
            }
        }
    });
    charts[f.id] = { chart: chart, data: f, maxIndex: maxIndex };
    updateYScale(chart);
    const det = document.getElementById('details-' + f.id);
    det.parentElement.addEventListener('toggle', e => {
        if (e.target.open) loadDetails(f.id);
    }, {once: true});

    // manual drag-to-pan so users can explore the timeline without modifiers
    let startX = null;
    ctx.canvas.addEventListener('mousedown', e => {
        startX = e.offsetX;
    });
    ctx.canvas.addEventListener('mousemove', e => {
        if (startX === null) return;
        const info = charts[f.id];
        const opts = info.chart.options.scales.x;
        const chartArea = info.chart.chartArea;
        const delta = (startX - e.offsetX) * (opts.max - opts.min) / (chartArea.right - chartArea.left);
        let newMin = opts.min + delta;
        let newMax = opts.max + delta;
        const range = opts.max - opts.min;
        if (newMin < 0) {
            newMin = 0;
            newMax = range;
        }
        if (newMax > info.maxIndex) {
            newMax = info.maxIndex;
            newMin = newMax - range;
        }
        opts.min = newMin;
        opts.max = newMax;
        startX = e.offsetX;
        info.chart.update('none');
    });
    ['mouseup','mouseleave'].forEach(evt => ctx.canvas.addEventListener(evt, () => startX = null));
    document.getElementById('scale-' + f.id).addEventListener('change', e => {
        const scale = e.target.value;
        const info = charts[f.id];
        info.chart.data.labels = info.data.labels[scale];
        info.chart.data.datasets[0].data = info.data.actualData[scale];
        info.chart.data.datasets[1].data = info.data.forecastData[scale];
        const range = computeRange(scale, info.data.labels[scale], info.data.actualData[scale]);
        info.maxIndex = info.data.labels[scale].length - 1;
        info.chart.options.scales.x.min = range.min;
        info.chart.options.scales.x.max = Math.min(range.max, info.maxIndex);
        updateYScale(info.chart);
        info.chart.update();
    });
});
/*]]>*/
</script>
</body>
</html>
